---
typora-copy-images-to: image
---

# 前端基础

### 基本类型

boolean、null、undefined、number、string、symbol

首先原始类型存储的都是值，是没有函数可以调用的，比如 undefined.toString()    

//Uncaught TypeError: Cannot read property 'toString' of undefined at <anonymous>:1:11



数参数是对象

```javascript
function test(person) {
  person.age = 26
  person = {
    name: "yyy",
    age: 30
  }
 
  return person
}
const p1 = {
  name: "xxx",
  age: 25
}
const p2 = test(p1)
console.log(p1) // ->{name: "xxx", age: 26}
console.log(p2) // -> {name: "yyy", age: 30}
```

解：
函数传递的是对象指针的副本
当到函数内部修改参数属性，p1被修改
当在重新为person分配了一个对象此时放回的person的地址是一个新的地址不影响p1

### 类型判断--typeof

**原始类型的判断使用typeof，除了null之外都可判断正确的类型（null判断出来是Object，）**

typeof null 会输出 object   ------ 在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来

但typeof对于对象来说，除了函数都会显示object，所以所以说typeof并不能准确判断变脸到底是什么类型

```javascript
typeof [] // ’object’
typeof {} // ’object’
typeof console.log  // ’function’
```

### 对象判断---instanceof

判断对象还是考虑使用instanceof，但使用instanceof是无法判断直接原始类型的，所以instanceof也不能百分百可信；例如：

```javascript
“hellow world” instanceof String    //false

而需要 new String("hellow world") instanceof String  //true
```

可以使用Symbol.hasInstance自定义instanceof的行为

``` javascript
class PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === 'string'
  }
}
console.log('hello world' instanceof PrimitiveString) // true
```

### 类型转换

``` javascript
number => boolean   除了0、-0、NaN都为true
string => boolean 除了空字符串都为true
undefined、null => boolean   false
引用类型(array,object即使是为空) =>boolean   true
number => string  例：5=>'5'
boolean、函数、Symbol => string   例：true => "true"
array => string  例：[1,2] => "1,2"
Object => string  例：{}  => "[object,object]"
string => number   例子：“1”=> 1       "a"=> NaN
array => number  空数组为0，存在一个元素且为数字转成数字，其他情况NaN
除了数组的引用类型 =>number   NaN
symbol => number  抛出错误
```

### 转Boolean

在条件判断时，除了 undefined， null， false， NaN， '' (空字符串)， 0， -0，其他所有值都转为 true，包括所有对象。

### 对象转基本类型

对象在转基本类型的时候会调用内置的[[ToPrimitive]]，该函数的内部执行：如果不是基本类型则会调用 x.valueOf()方法，x.toString()；返回转换的值

对象类型转换，在对象进行类型转换的时候我们可以重写valueOf，toString方法。

#### 面试题：

​	**var a = {num: 0},使if(a == 1&& a==2&&a==3){console.log('ok')},打印出ok**

解：

```javascript
var a = {num:0}
a.valueOf = function(){ return ++a.num }
if(a ==1&&a==2&&a==3){ console.log(‘ok’) }
```

也可以重写Symbol.toPrimitive，该方法在转原始类型时调用优先级最高

(优先级：Symbol.toPrimitive  >  valueOf  >  toString )

```javascript
var a = {
  num: 0,
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  },
  [Symbol.toPrimitive]() {
    return ++this.num
  }
}
if(a==1&&a==2&&a==3){ console.log('ok') }
```

### 四则运算符

#### 加法运算符

加法运算符不同于其他几个运算符，加法运算符特点如下：

1. 运算中其中一方为字符串，另一方也转为字符串  例：1+ '1' // 11    ;   true + true  // 2

2. 如果一方不是字符串或者数字，那么会将他转换为数字或者字符串     例：2 + [1,2,3]  // “21,2,3'   此处数组通过toString转为字符串 '1,2,3'

```javascript
注意： 'a' + + 'b'  // ’aNaN’  因为 +’b’ 结果为NaN
```

除了加法的其他运算符，只要其中一方为数字，那么另一方就会转为数字

```javascript
4 * '3'  // 12
4 * []  // 0 空数组转数字为0
4 * [1,2]  //NaN  非空数组转数字为NaN
```

#### 比较运算符

1. 如果是对象，就通过toPrimitive 转换对象

2. 如果是字符串，就通过unicode字符索引来比较

例如：

对象：

```javascript
let a = {
valueOf(){
return 0
},
toString(){
return '1'
}
}
a > -1  // true  跟上面的面试题类似 转换的时候调用valueOf转换为原始类型
```

求与字符串相加之和，使用Number(xx)，进行类型转换再进行相加

#### 面试题

0.1 + 0.2 != 0.3

因为计算机对数据的存储是使用二进制的，很多小数在二进制中是无限循环的一些数字，js使用了浮点数标准（IEE754）会裁剪其中的数字，会将64位的二进制数分为三段：第一位表示符号，11位用来表示指数，其他位表示有效位

```javascript
0.20000000000000000000000000002 === 0.2 //true
```

```javascript
0.1+0.2   //0.30000000000000004
```

使用toFixed()方法，规定小数的位数

```javascript
parseFloat((0.1+0.2).toFixed(10)) === 0.3
```



### 等号 ==

等号 == 存在着隐式转换，比较前

1. 先判断两边的类型是否相同，相同的话就比较大小
2. 不相同的话就判断两边是否为null和undefined比较，是则返回true，不是则进行类型转换
3. 判断是否为string类型和number类型，是的话将string转number
4. 判断其中一方是否为boolean类型，是的话就会把boolean转为number类型
5. 判断其中一方是否为object类型，且另一方为string、number、symbol类型，是的话就将object类型转成原始类型再进行判断



#### 注意：

1. 如果两者都为引用类型（array，object），则比较的是两边的地址

   例如

   ```javascript
   []==[] //false 
   {}=={} //false
   ```

2. 如果两者的类型不一样则转换为number类型，如果存在一边是boolean类型，则boolean类型转换成number类型，再进行比较

   

我们一起来看看下面的这两个隐式转换

```javascript
[] ==![] 和 {} ==!{}
```

上面讲过[]==[]和{}=={}两者都为false，那么[]==![]和{}==!{}又是什么呢，这里应该看到这么问，大家都觉得是有坑是吧哈哈哈，[]==![]为true；{}==!{}为false；为什么呢

#### 解：[] == ![]     //true

[]==![]  因为逻辑运算符 ! 的优先级是大于==的，所以我们先看右边，![]因为[]转布尔类型是true，因为引用类型（array，object）转boolean都为true，所以![]为false，==的运算顺序是从左到右，因为两边比较的类型不相同，所以[]转number类型为0，false转number类型也为0，所以两边都为0，所以为true

先右边：![]  ->  !true  ->  false  ->  0

再到左边： []  ->(引用类型转number) 0

#### 解：{} == !{}    //false

{}==!{}同理，{}先转成原始类型[object object],然后转boolean类型为true，然后!{}为false，false转number类型为0，而{}转number类型为NaN，所以NaN == 0 为false，（因为无论是使用==还是===和任何类型比较的结果都为false包括和它本身比较，那么怎么判断NaN呢，这里需要用到Number的自带方法--- Number.isNaN(xxx)返回的是一个布尔值）

先右边： !{}  ->  !true  ->  false  -> 0

再左边： {}  -> (引用类型转number) NaN



发现最后都是往boolean和number类型的转换，最后比较两边是否相等



### 全等 ===

#### 全等：不存在隐式转换

但是

```javascript
NaN === NaN // false
+0 === -0 //true
```

这里NaN理论上应该是相等的才对啊是吧，而正零和负零应该是不相等才对啊，那么如果我们需要正确判断他们，但是全等又不准确，那怎么办呢



#### Object.is()

这个方法跟全等差不多，判断两个值是否为同一个值，是可以区分正负零和判断出NaN

```javascript
Object.is(-0,+0)  //false
Object.is(NaN,NaN) //true
```

但是这个方法存在兼容问题：**IE是不兼容的**，如果用在小程序还好，用在pc或者h5端的话慎重！

![1614096186752](image/1614096186752.png)