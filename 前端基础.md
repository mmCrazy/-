---
typora-copy-images-to: image
---

# 前端基础

### 基本类型

boolean、null、undefined、number、string、symbol

首先原始类型存储的都是值，是没有函数可以调用的，比如 undefined.toString()    

//Uncaught TypeError: Cannot read property 'toString' of undefined at <anonymous>:1:11



数参数是对象

```javascript
function test(person) {
  person.age = 26
  person = {
    name: "yyy",
    age: 30
  }
 
  return person
}
const p1 = {
  name: "xxx",
  age: 25
}
const p2 = test(p1)
console.log(p1) // ->{name: "xxx", age: 26}
console.log(p2) // -> {name: "yyy", age: 30}
```

解：
函数传递的是对象指针的副本
当到函数内部修改参数属性，p1被修改
当在重新为person分配了一个对象此时放回的person的地址是一个新的地址不影响p1

### 类型判断--typeof

**原始类型的判断使用typeof，除了null之外都可判断正确的类型（null判断出来是Object，）**

typeof null 会输出 object   ------ 在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来

但typeof对于对象来说，除了函数都会显示object，所以所以说typeof并不能准确判断变脸到底是什么类型

```javascript
typeof [] // ’object’
typeof {} // ’object’
typeof console.log  // ’function’
```

### 对象判断---instanceof

判断对象还是考虑使用instanceof，但使用instanceof是无法判断直接原始类型的，所以instanceof也不能百分百可信；例如：

```javascript
“hellow world” instanceof String    //false

而需要 new String("hellow world") instanceof String  //true
```

可以使用Symbol.hasInstance自定义instanceof的行为

``` javascript
class PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === 'string'
  }
}
console.log('hello world' instanceof PrimitiveString) // true
```

### 类型转换

``` javascript
number => boolean   除了0、-0、NaN都为true
string => boolean 除了空字符串都为true
undefined、null => boolean   false
引用类型(array,object即使是为空) =>boolean   true
number => string  例：5=>'5'
boolean、函数、Symbol => string   例：true => "true"
array => string  例：[1,2] => "1,2"
Object => string  例：{}  => "[object,object]"
string => number   例子：“1”=> 1       "a"=> NaN
array => number  空数组为0，存在一个元素且为数字转成数字，其他情况NaN
除了数组的引用类型 =>number   NaN
symbol => number  抛出错误
```

### 转Boolean

在条件判断时，除了 undefined， null， false， NaN， '' (空字符串)， 0， -0，其他所有值都转为 true，包括所有对象。

### 对象转基本类型

对象在转基本类型的时候会调用内置的[[ToPrimitive]]，该函数的内部执行：如果不是基本类型则会调用 x.valueOf()方法，x.toString()；返回转换的值

对象类型转换，在对象进行类型转换的时候我们可以重写valueOf，toString方法。

#### 面试题：

​	**var a = {num: 0},使if(a == 1&& a==2&&a==3){console.log('ok')},打印出ok**

解：

```javascript
var a = {num:0}
a.valueOf = function(){ return ++a.num }
if(a ==1&&a==2&&a==3){ console.log(‘ok’) }
```

也可以重写Symbol.toPrimitive，该方法在转原始类型时调用优先级最高

(优先级：Symbol.toPrimitive  >  valueOf  >  toString )

```javascript
var a = {
  num: 0,
  valueOf() {
    return 0
  },
  toString() {
    return '1'
  },
  [Symbol.toPrimitive]() {
    return ++this.num
  }
}
if(a==1&&a==2&&a==3){ console.log('ok') }
```

### 四则运算符

#### 加法运算符

加法运算符不同于其他几个运算符，加法运算符特点如下：

1. 运算中其中一方为字符串，另一方也转为字符串  例：1+ '1' // 11    ;   true + true  // 2

2. 如果一方不是字符串或者数字，那么会将他转换为数字或者字符串     例：2 + [1,2,3]  // “21,2,3'   此处数组通过toString转为字符串 '1,2,3'

```javascript
注意： 'a' + + 'b'  // ’aNaN’  因为 +’b’ 结果为NaN
```

除了加法的其他运算符，只要其中一方为数字，那么另一方就会转为数字

```javascript
4 * '3'  // 12
4 * []  // 0 空数组转数字为0
4 * [1,2]  //NaN  非空数组转数字为NaN
```

#### 比较运算符

1. 如果是对象，就通过toPrimitive 转换对象

2. 如果是字符串，就通过unicode字符索引来比较

例如：

对象：

```javascript
let a = {
valueOf(){
return 0
},
toString(){
return ‘1’
}
}
a > -1  // true  跟上面的面试题类似 转换的时候调用valueOf转换为原始类型
```

