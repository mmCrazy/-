基本类型

boolean、null、undefined、number、string、symbol

首先原始类型存储的都是值，是没有函数可以调用的，比如 undefined.toString()    

//Uncaught TypeError: Cannot read property 'toString' of undefined at <anonymous>:1:11

 

函数参数是对象

```javascript
function test(person) {
  person.age = 26
  person = {
    name: "yyy",
    age: 30
  }

  return person
}
const p1 = {
  name: "xxx",
  age: 25
}
const p2 = test(p1)
console.log(p1) // ->{name: "xxx", age: 26}
console.log(p2) // -> {name: "yyy", age: 30}
```

函数传递的是对象指针的副本

当到函数内部修改参数属性，p1被修改

当在重新为person分配了一个对象此时放回的person的地址是一个新的地址不影响p1

 

类型判断--typeof

原始类型的判断使用typeof，除了null之外都可判断正确的类型（null判断出来是Object，）

typeof null 会输出 object    ------ 在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来

但typeof对于对象来说，除了函数都会显示object，所以所以说typeof并不能准确判断变脸到底是什么类型

```javascript
typeof [] // ’object’
typeof {} // ’object’
typeof console.log  // ’function’
```

 

对象判断---instanceof

判断对象还是考虑使用instanceof，但使用instanceof是无法判断直接原始类型的，所以instanceof也不能百分百可信；例如：

“hellow world” instanceof String       //false      

而需要 new String("hellow world") instanceof String  //true

可以使用Symbol.hasInstance自定义instanceof的行为

```javascript
class PrimitiveString {
  static [Symbol.hasInstance](x) {
    return typeof x === 'string'
  }
}
console.log('hello world' instanceof PrimitiveString) // true
```

 

 

类型转换

```javascript
number => boolean   除了0、-0、NaN都为true
string => boolean 除了空字符串都为true
undefined、null => boolean   false
引用类型(array,object即使是为空) =>boolean   true
number => string  例：5=>'5'
boolean、函数、Symbol => string   例：true => "true"
array => string  例：[1,2] => "1,2"
Object => string  例：{ }  => "[object,object]"
string => number   例子：“1”=> 1       "a"=> NaN
array => number  空数组为0，存在一个元素且为数字转成数字，其他情况NaN
除了数组的引用类型 =>number   NaN
symbol => number  抛出错误
```

转Boolean

在条件判断时，除了 undefined， null， false， NaN， '' (空字符串)， 0， -0，其他所有值都转为 true，包括所有对象。

 

对象转基本类型

对象在转基本类型的时候会调用内置的[[ToPrimitive]]，该函数的内部执行：如果不是基本类型则会调用 x.valueOf()方法，x.toString()；返回转换的值

对象类型转换，在对象进行类型转换的时候我们可以重写valueOf，toString方法。

面试题:

```javascript
var a = {num:0}
a.valueOf = function(){ return ++a.num }
if(a ==1&&a==2&&a==3){ console.log(‘ok’) }
```

 

也可以重写Symbol.toPrimitive，该方法在转原始类型时调用优先级最高

```javascript
let a = {
  valueOf(){
 return 0
},
toString(){
 return ‘1’
},
[Symbol.toPrimtive](){
 return 2
}
}
1 + a   //  3
```

 

四则运算符

加法运算符不同于其他几个运算符，加法运算符特点如下：

\1. 运算中其中一方为字符串，另一方也转为字符串  例：1+ ‘1’  // 11     true + true  // 2

\2. 如果一方不是字符串或者数字，那么会将他转换为数字或者字符串        例：2 + [1,2,3]  // “21,2,3”     此处数组通过toString转为字符串 “1,2,3”

 

```javascript
注意： ‘a’ + + ‘b’  // ’aNaN’  因为 +’b’ 结果为NaN 
```

 

除了加法的其他运算符，只要其中一方为数字，那么另一方就会转为数字

```javascript
4 * ’3’  // 12
4 * []  // 0 空数组转数字为0
4 * [1,2]  //NaN  非空数组转数字为NaN
```

 

比较运算符

\1. 如果是对象，就通过toPrimitive 转换对象

\2. 如果是字符串，就通过unicode字符索引来比较

例如：

对象：

```javascript
let a = {
valueOf(){
return 0
},
toString(){
return ‘1’
}
}
a > -1  // true  跟上面的面试题类似 转换的时候调用valueOf转换为原始类型
```

 

求与字符串相加之和，使用Number(xx),进行类型转换再进行相加



面试题

0.1+0.2 != 0.3



因为计算机对数据的存储是使用二进制的，很多小数在二进制中是无限循环的一些数字，js使用了浮点数标准（IEE 754）会裁剪其中的数字，会将64位的二进制数分为三段：第一位表示符号，11位用来表示指数，其他位表示有效位



0.20000000000000000000000000002 === 0.2 //true 



0.1+0.2   //0.30000000000000004 



使用toFixed()方法，规定小数的位数

parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 







this

非严格模式下，function的this指向window

一个对象中谁调用this，this就指向谁

new 一个对象，this就绑定到这个对象

箭头函数是没有this的，在箭头函数中调用this是会在上一层作用域去查找，没有则再向上查找，直到查找到最外层的window的作用域，指向window为止，注意：箭头函数是无法通过bind，call，apply改变this的指向的

let fn2 = function fn1() {   return function() {     return fn.apply()   }.apply(a) } fn2() 

可以从上述代码中发现，不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window

 

一般情况下我们可以使用bind，apply，call方法改变this的指向例如：

let a = { name: ‘小明’} function foo(){ Console.log(this.name) } foo.bind(a)()   // 小明 

但可能有时候会出现多个不同情况，需要根据优先级的最高来决定this的最终指向

this的最终指向优先级大-->小 ： new -> bind,call,apply->静态量调用obj.foo()的调用形式->foo的调用形式

注意：箭头函数的this一但被绑定，就不会再被任何方式改变



==

==存在着隐式转换，比较前

\1. 先判断两边的是否类型是否相同，相同的话就比较大小，

\2. 不相同的话就判断两边是否为null和undefined比较，是则返回true，不是则进行类型转换，

\3. 判断是否为string类型和number类型，是的话将string转number

\4. 判断其中一方是否为boolean类型，是的话就会把boolean转为number类型

\5. 判断其中一方是否为object类型，且另一方为string、number、symbol类型，是的话就将object类型转成原始类型再进行判断

 

注意：

1.如果两者都为引用类型（array，object），则比较的是两边的地址，

例如[]==[] //false； {}=={}//false

2.如果两者的类型不一样则转换为number类型，如果存在一边是boolean类型，则boolean类型转换成number类型，再进行比较

 

我们一起来看看下面的这两个隐式转换

[] ==![] 和{} ==!{}

 

上面讲过[]==[]和{}=={}两者都为false，那么[]==![]和{}==!{}又是什么呢，这里应该看到这么问，大家都觉得是有坑是吧哈哈哈，[]==![]为true；{}==!{}为false；为什么呢

[]==![]  因为逻辑运算符 ! 的优先级是大于==的，所以我们先看右边，![]因为[]转布尔类型是true，因为引用类型（array，object）转boolean都为true，所以![]为false，==的运算顺序是从左到右，因为两边比较的类型不相同，所以[]转number类型为0，false转number类型也为0，所以两边都为0，所以为true

先右边：![]  ->  !true  ->  false  ->  0

再到左边： []  ->(引用类型转number) 0

 

{}==!{}同理，{}先转成原始类型[object object],然后转boolean类型为true，然后!{}为false，false转number类型为0，而{}转number类型为NaN，所以NaN == 0 为false，（因为无论是使用==还是===和任何类型比较的结果都为false包括和它本身比较，那么怎么判断NaN呢，这里需要用到Number的自带方法--- Number.isNaN(xxx)返回的是一个布尔值）

先右边： !{}  ->  !true  ->  false  -> 0

再左边： {}  -> (引用类型转number) NaN

 

发现最后都是往boolean和number类型的转换，最后比较两边是否相等

 

===（这个相信大家都熟悉了，我就不多讲了，这个不存在隐式转换）

 

 

闭包

闭包就是函数A内部有一个函数B，函数B可以访问到函数A中的变量，那么函数B就是闭包

例如：

function(){ var a = 1 return function (){ Conso.log(a) } }   for(var i = 1;i<=5;i++){ setTimeout(function timer(){ console.log(i) },i*1000) } 

上面输出的结果都是6，因为定时器是宏任务，是异步的所以当执行定时器的时候，此时的i已经是6了

所以我们可以使用闭包的方式，来解决这个问题，输出我们想要的结果（输出1到5）

for(var i = 1;i<=5;i++){ (fucntion(j){ setTimeout(function(){ console.log(j); },j*1000) })(i) } 

当然了解决这个问题的方法其实也不止这个，还可以使用setTimeout的第三个参数,这个参数会当中timer函数的参数传入

for(var i = 1;i <=5;i++){ setTimeout(function timer(j){ console.log(j) },i*1000,i) } 

还有一种方法是使用块级作用域let变量声明

for(let i =1;i<=5;i++){ setTimeout(function(){ console.log(i) },i*1000) } 

 

浅拷贝

有些时候，我们需要操作对象类型的数据，但并不希望它影响到原数据，这时我们就可以使用浅拷贝来解决这个问题，因为引用类型的赋值就是复制了地址，修改了其中一个，另一个也会跟着修改

例如：

var a = { age: 1 } var b = a b.age = 2   console.log(a.age)   //2 

 

浅拷贝：

可以使用ES6的assign，assign会将所有属性的值拷贝到新的对象中，如果拷贝的属性值是对象的话，拷贝的是地址

var a = { age: 1 } var b = Object.assgin({},a) b.age = 2 console.log(a.age)  //1 

 

还可以使用...运算符实现浅拷贝

var a ={ age:1 } var b = {...a} b.age = 2 console.log(a.age)   //1 

 

 

 

浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。

var a = { name:{ age: 1 } } var b = object.assign({},a) b.name.age =2 console.log(a.name.age)  //2 

 

 

深拷贝

可以使用JSON.parse(JSON.stringify(object))实现深拷贝,解决深层嵌套的问题

var a = { name:{ age: 1 } } var b = JSON.parse(JSON.stringify(a)) b.name.age =2 console.log(a.name.age)  //1 

但这个方法存在缺点：undefined（被忽略）和function（被忽略）还有symbol类型（被忽略），还有循环引用的对象（报错）是无法进行深拷贝的，如果需要可以自己手动封装函数

var a = { b: undefined, c:function(){}, d:Symbol(1), e: 132 } var b = JSON.parse(JSON.stringify(a)) console.log(b)  // { e: 132 } 

 

使用JSON.parse(JSON.stringify(obj))深拷贝循环引用的对象会报错

var obj = { a: 1, b: { c: 2 } } obj.b.d = obj.b var b = JSON.parse(JSON.stringify(obj)) 



![img](D:\Java\weixinobU7VjnJQvjpTF8-cOHEgZid2kUY\0c09e8d85f5f470a8f6d8e9b3fce31b7\wps1.jpeg)

 

 

还有一种建立消息通道的方法，使用MessageChannel，实例化对象，我们可以看下这个对象的属性

![img](D:\Java\weixinobU7VjnJQvjpTF8-cOHEgZid2kUY\435866f485f94b9082caf7a59115fecf\wps2.jpeg)

 

这是两个回调的方法，使用MessagePort.portMessage方法发送消息的时候，就会触发另一个端口的onMessage消息通道，然后port1和port2是可以相互发送消息的

var channel = new MessageChannel(); var port1 = channel.port1; var port2 = channel.port2; port1.onmessage = function (event) {   console.log("port2对port1说："+event.data); } port2.onmessage = function (event) {   console.log("port1对port2说："+event.data); } port1.postMessage("Hello"); port2.postMessage("Hi"); 输出的结果： //port1对port2说：Hello //port2对port1说：Hi 

 

通过MessageChannel实例的postMessage()方法传输的message参数是深拷贝的，所以可以使用MessageChannel实现深拷贝

//深拷贝函数

function deepClone(val){     return new Promise(resolve=>{         const {port1,port2} = new MessageChannel()         port2.onmessage = e=> resolve(e.data)         port1.postMessage(val)     }) } //定义一个包含undefined的对象 let obj = {     a: 1,     b:undefined,     c:{         d:1     } } //循环引用 obj.c.e = obj.c     //注意这里的方法是异步的 async function test(){   const clone = await deepClone(obj) } test() 

 

原型

每个实例对象里都有一个下划线原型_proto_，该原型指向prototype，该原型是用来共享实例和方法的，prototype里面有一个构造函数constructor里面是用来存放共享的方法

 

所有的对象的最终的指向是Object

所有函数的最终指向是Function

函数的prototype是一个对象

对象的_proto_属性指向原型，_proto_将对象和原型连接起来组成的原型链

 

原型链

function person(name,age){     this.name = name     this.age = age } person.prototype.run = function(){     console.log(this.name) } var a = new person('xiaoming',12) console.dir(a) 

结果如下截图

![img](D:\Java\weixinobU7VjnJQvjpTF8-cOHEgZid2kUY\f4f7d38d94d84f17a6d62a9761d6d731\clipboard.png)



这样看着好像还是有点混乱,那么请看下图

![img](D:\Java\weixinobU7VjnJQvjpTF8-cOHEgZid2kUY\f56fe8a43e5848f487f8fa69f85f5ee1\clipboard.png)



原型继承和class继承

原型继承：

function Parent(name,age){     this.name = name     this.age = age } Parent.prototype.run = function(){     console.log(this.name) } function Child(){} Child.prototype = new Parent() const child = new Child() console.log(child) 

child的结构如下图：

![img](D:\Java\weixinobU7VjnJQvjpTF8-cOHEgZid2kUY\4e9fdc2b8d554bf28b9bdc23c3c60003\clipboard.png)

注意：此方法只继承到了Parent的方法(run)，没有继承到Parent的属性(name,age)



借用构造函数实现继承（call，apply，bind方法实现继承（通过改变this的指向实现继承），这三个方法的用法就不在这细讲，原理都一样，这里用call来作例子）

function Parent(name,age){ this.name = name this.age = age } Parent.prototype.run = function(){ console.log(this.name) } function Child(name,age){ Parent.call(this,name,age) } const child = new Child("xiaoming","12") console.log(child) 

child的结构如下图

![img](D:\Java\weixinobU7VjnJQvjpTF8-cOHEgZid2kUY\738541f5578b4402a558ee1e839ae701\clipboard.png)

注意：此方法只继承了Parent的属性，但不能继承到Parent的方法

 

组合继承（没错就是上面两个继承方式的组合）:

```javascript
function Parent(name,age){     this.name = name     this.age = age } Parent.prototype.run = function (){     console.log(this.name) } function Child(name,age){     Parent.call(this,name,age)  //继承属性 }  Child.prototype = new Parent() //调用构造函数的时候会为实例添加一个指向最初原型prototype指针----继承Parent原型（prototype）中共享的方法 Child.prototype.constructor = Child    //这里不改变原型的构造器，则会指向Parent的构造器 const child = new Child("xiaoming","12") child.run() //xiaoming child instanceof Parent //true 
```







寄生组合继承---继承的方案中比较完美的，在组合继承中省去了继承父类的无用属性的内存占用

function Parent(name,age){     this.name = name     this.age = age } Parent.prototype.run = function(){     console.log(this.name) }  function Child(name,age){     Parent.call(this,name,age) }  Child.prototype = Object.create(Parent.prototype,{        constructor:{         //重写构造函数         value: Child,         enumerable:false,     //是否可枚举         writable: true,       //是否可修改         configurable: true    //是否可配置     } })  const child = new Child('xiaoming','12') child.run()  //xiaoming child instanceof Parent //true 



console.log(child) 

child的结构如下图：

![img](D:\Java\weixinobU7VjnJQvjpTF8-cOHEgZid2kUY\8eb22d1e14a349a8a030c6e788a99d1b\clipboard.png)



![img](D:\Java\weixinobU7VjnJQvjpTF8-cOHEgZid2kUY\81f0ca1b92bb4141a4f88f40a968e9ca\clipboard.png)





class继承

class是语法糖，本质还是函数
